name: Deploy Node.js App to EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REPO: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/nodejs-app

jobs:
  provision-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      ecr_repo_url: ${{ steps.terraform.outputs.ecr_repo_url }}
      rds_endpoint: ${{ steps.terraform.outputs.rds_endpoint }}
      cluster_name: ${{ steps.terraform.outputs.cluster_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init
        run: terraform init
        working-directory: infra

      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: infra
        env:
          TF_VAR_rds_password: ${{ secrets.RDS_PASSWORD }}
          TF_VAR_cluster_name: ${{ env.CLUSTER_NAME }}
          TF_VAR_region: ${{ env.AWS_REGION }}

      - name: Get Terraform outputs
        id: terraform
        run: |
          # Try JSON output
          if terraform output -json > outputs.json 2>/dev/null; then
            ECR_REPO_URL=$(jq -r '.ecr_repository_url.value' outputs.json)
            RDS_ENDPOINT=$(jq -r '.rds_endpoint.value' outputs.json)
            CLUSTER_NAME=$(jq -r '.cluster_name.value' outputs.json)
            rm outputs.json
          else
            ECR_REPO_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
            RDS_ENDPOINT=$(terraform output -raw rds_endpoint 2>/dev/null || echo "")
            CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          fi

          echo "ecr_repo_url=$ECR_REPO_URL" >> $GITHUB_OUTPUT
          echo "rds_endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
        working-directory: infra

  deploy-application:
    runs-on: ubuntu-latest
    needs: provision-infrastructure
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      CLUSTER_NAME: ${{ needs.provision-infrastructure.outputs.cluster_name }}
      RDS_ENDPOINT: ${{ needs.provision-infrastructure.outputs.rds_endpoint }}
      ECR_REPO_URL: ${{ needs.provision-infrastructure.outputs.ecr_repo_url }}
      ECR_REPO: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/nodejs-app
      GITHUB_SHA: ${{ github.sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push Docker image
        run: |
          echo "ECR_REPO_URL: '$ECR_REPO_URL'"
          echo "ECR_REPO: '$ECR_REPO'"
          echo "GITHUB_SHA: '$GITHUB_SHA'"

          if [[ -n "$ECR_REPO_URL" ]]; then
            IMAGE_URI="$ECR_REPO_URL"
          else
            IMAGE_URI="$ECR_REPO"
          fi

          if ! [[ "$IMAGE_URI" =~ ^[0-9]+\.dkr\.ecr\.[a-z0-9-]+\.amazonaws\.com\/.+$ ]]; then
            echo "Error: invalid ECR URI: $IMAGE_URI"
            exit 1
          fi

          docker build -t $IMAGE_URI:$GITHUB_SHA -f app/Dockerfile ./app
          docker push $IMAGE_URI:$GITHUB_SHA
          docker tag $IMAGE_URI:$GITHUB_SHA $IMAGE_URI:latest
          docker push $IMAGE_URI:latest

          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          docker tag $IMAGE_URI:$GITHUB_SHA $IMAGE_URI:build-$TIMESTAMP
          docker push $IMAGE_URI:build-$TIMESTAMP

          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      - name: Verify EKS cluster endpoint reachability
        run: |
          ENDPOINT=$(aws eks describe-cluster --name $CLUSTER_NAME --region $AWS_REGION --query 'cluster.endpoint' --output text)
          if curl -m 10 -sf $ENDPOINT; then
            echo "Cluster endpoint reachable"
          else
            echo "Cannot reach cluster endpoint"
            exit 1
          fi

      - name: Configure kubectl
        run: |
          retries=3; count=0
          until aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_REGION || [ $count -ge $retries ]; do
            count=$((count+1))
            echo "Retrying kubectl config ($count/$retries)…"
            sleep 10
          done
          if [ $count -ge $retries ]; then exit 1; fi

      - name: Test kubectl connectivity
        run: |
          retries=3; count=0
          until kubectl get nodes --request-timeout=10s || [ $count -ge $retries ]; do
            count=$((count+1))
            echo "Retrying kubectl connectivity ($count/$retries)…"
            sleep 15
          done
          if [ $count -ge $retries ]; then exit 1; fi

      - name: Create or update Kubernetes secret
        run: |
          SECRET_YAML=$(kubectl create secret generic db-secret \
            --from-literal=password=${{ secrets.RDS_PASSWORD }} \
            --dry-run=client -o yaml)
          kubectl apply -f - <<<"$SECRET_YAML"

      - name: Deploy Node.js application
        run: |
          DOCKER_IMAGE="${IMAGE_URI:-$ECR_REPO_URL}:${GITHUB_SHA}"
          echo "Deploying image: $DOCKER_IMAGE"

          sed -i "s|{{IMAGE_URI}}|$DOCKER_IMAGE|g" k8s/deployment.yaml
          sed -i "s|{{RDS_ENDPOINT}}|$RDS_ENDPOINT|g" k8s/deployment.yaml

          retries=3; count=0
          until kubectl apply -f k8s/deployment.yaml --request-timeout=60s \
             && kubectl apply -f k8s/service.yaml --request-timeout=60s \
             || [ $count -ge $retries ]; do
            count=$((count+1))
            echo "Retrying apply manifests ($count/$retries)…"
            sleep 15
          done
          if [ $count -ge $retries ]; then exit 1; fi

          kubectl rollout status deployment/nodejs-app --timeout=300s

      - name: Deploy monitoring stack
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm upgrade --install prometheus-stack prometheus-community/kube-prometheus-stack \
            --namespace monitoring --create-namespace \
            --set grafana.adminPassword=${{ secrets.GRAFANA_ADMIN_PASSWORD }} \
            --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
            --set prometheus.prometheusSpec.podMonitorSelectorNilUsesHelmValues=false \
            --timeout=10m
